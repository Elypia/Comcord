package com.elypia.webhooker;

import com.elypia.webhooker.annotation.Mapping;
import org.slf4j.*;

import java.io.*;
import java.lang.reflect.Method;
import java.net.ServerSocket;
import java.util.*;

import static spark.Spark.*;

/**
 * This class should be used as a singleton where possible.
 * There is no need to create multiple web servers.
 * Regardless of service map the payload where it needs to go and perform
 * the task as required.
 */
public class WebHooker implements Closeable {

    private static final Logger logger = LoggerFactory.getLogger(WebHooker.class);
    private static final String PATH = "/%s/:class/:method";

    private final String domain;

    /**
     * The endpoint used to receive webhook payloads is comprised of
     * 3 parts. <br>
     * <strong>UUID:</strong> A randomly generated UUID to
     * make webhook URLS less predictable.
     * (This is generated by WebHooker.)<br>
     * <strong>Module:</strong> An indicator of which payload receiver
     * to relay this payload to. <br>
     * <strong>Request:</strong> An indicator of which method to relay
     * the payload to.
     */
    private final String endpoint;

    private final Collection<Receiver> receivers;
    private final PayloadDispatcher dispatcher;
    private final Set<String> mappings;


    public WebHooker(String domain) throws IOException {
        this(domain, 0);
    }

    public WebHooker(String domain, int port) throws IOException {
        this(domain, port, UUID.randomUUID());
    }

    public WebHooker(String domain, int port, UUID uuid) throws IOException {
        if (port == 0) {
            try (ServerSocket socket = new ServerSocket(0)) {
                port = socket.getLocalPort();
            }
        }

        this.domain = domain;
        endpoint = String.format(PATH, uuid);
        receivers = new ArrayList<>();
        dispatcher = new PayloadDispatcher(this);
        mappings = new HashSet<>();

        port(port);

        post(endpoint, (request, response) -> {
            dispatcher.dispatch(request, response);
            return response.body();
        });
    }

    public boolean add(Receiver... rec) {
        boolean changed = false;

        for (Receiver receiver : rec) {
            Class<? extends Receiver> clazz = receiver.getClass();

            if (!clazz.isAnnotationPresent(Mapping.class))
                throw new IllegalArgumentException("Receiver must always have @Mapping annotation to indicate webhook path.");

            Mapping classMapping = clazz.getAnnotation(Mapping.class);
            String classValue = classMapping.value();

            if (classValue.length() == 0)
                throw new IllegalArgumentException("Receiver can't have a @Mapping value of length zero.");

            if (!mappings.add(classValue))
                throw new IllegalArgumentException("Receiver with @Mapping value already exists.");

            Set<String> methodMappings = new HashSet<>();
            int mappedMethods = 0;

            for (Method method : clazz.getMethods()) {
                if (!method.isAnnotationPresent(Mapping.class))
                    continue;

                Class<?>[] types = method.getParameterTypes();
                int length = types.length;

                if (length  > 2)
                    throw new IllegalArgumentException("Method with @Mapping can only have 0 to 2 parameters.");

                if (length > 0 && types[0] != Payload.class)
                    throw new IllegalArgumentException("If @Mapping specifies parameters, the first must be `Payload`.");

                Mapping methodMapping = method.getAnnotation(Mapping.class);
                String methodValue = methodMapping.value();

                if (methodValue.length() == 0)
                    throw new IllegalArgumentException("Method can't have a @Mapping value of length zero.");

                if (!methodMappings.add(methodValue))
                    throw new IllegalArgumentException("Method with @Mapping value already exists.");

                mappedMethods++;
            }

            if (mappedMethods == 0) {
                logger.warn("Receiver {} ignored as it had no method mappings.");
                continue;
            }

            if (receivers.add(receiver) && !changed)
                changed = true;
        }

        return changed;
    }

    public Collection<Receiver> getReceivers() {
        return receivers;
    }

    public String getUrl(String module, String request) {
        String url = domain;

        if (url.endsWith("/"))
            url = url.substring(0, url.length() - 1);

        if (port() != 80)
            url += ":" + port();

        return url + endpoint
            .replace(":class", module)
            .replace(":method", request);
    }

    @Override
    public void close() {
        stop();
    }
}
